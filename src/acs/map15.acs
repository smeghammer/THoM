#library "map15.acs"
#include "zcommon.acs"

/*
SCRIPT OPEN:
---------
*/

script 100 OPEN{
	/* set all fences blocking */
	int blockingfences[4] = {1,2,3,4};
	int blockingfencescount = 4;
	
	for(int a=0;a<blockingfencescount;a++){
		acs_execute(3,0,blockingfences[a],1);
		delay(1);
	}
	
}


/*
SCRIPT 1:
---------
*/
script 1 (void){
	Floor_LowerByValue(1,12,120);
	Delay(210);
	Floor_RaiseByValue(1,12,120);
	
	/* fullbright switch faces */
	
}

script 2 (int impaledCorpsesToGo, int spawnSpotId){
	/* remove the impaled corpses: */
	Thing_Remove(impaledCorpsesToGo);
	
	/* TEST - Replace with a randomised monster (get stronger as progress?) at relevant spawnspot */
	int thingsToSpawn[5] = {T_ZOMBIE,T_IMP,T_LOSTSOUL,T_SHOTGUY,T_CHAINGUY};
	
	Thing_Spawn(spawnSpotId, thingsToSpawn[Random(0,4)], 64);
	
	/* TODO: have multiple lines that trigger release of staked corpses - have counter on a complex array to
	keep track of whether a line has been triggered. I've done this before somewhere... */
}

/* steps and roof line blocking logic */
script 3 (int lineid, int blockingstate,int checkheightmapid){
	log(s:"blockingstate", i:blockingstate);
	print(s:"Player height: ",i:GetActorZ(0)/65536);
	int heightcheckmap[3] = {0,-1012,-840};
	
	/* if activeheight is passed, we test actor height and only allow the line blocking toggle to run if the user is at this height (=/-16) */
	int checkHeight = 1;
	if(checkheightmapid > 0){	/* some lines don't need testing */
		delay(1);
		print(s:"checking height:",i:GetActorZ(0)/65536);
		//delay(1);
		//print(s:"height: ",i:(GetActorZ(0)/65536));
		//delay(1);
		//print(s:"passed index: : ",i:checkheightmapid);
		//delay(1);
		//print(s:"active height: ",i:heightcheckmap[checkheightmapid]);
		checkHeight = 0;
		if( 
			(GetActorZ(0)/65536) <= heightcheckmap[checkheightmapid] + 32 
			&& 
			(GetActorZ(0)/65536) >= heightcheckmap[checkheightmapid] - 32
			){
		//if(  (heightcheckmap[checkheightmapid] - 32) <= (GetActorZ(0)/65536) <= (heightcheckmap[checkheightmapid] + 32) ){
			print(s:"unblock");
			checkHeight = 1;
		}
		//else{
		//	//debug
		//	print(s:"don't unblock");
		//}
	}

	
	if(checkHeight == 1){
		if(blockingstate == 1){
			print(s:"blocking line ",i:lineid);
			//Line_SetBlocking(lineid,32,0);	all
			Line_SetBlocking(lineid,64,0);
		}
		else{
			/* unblock */
			print(s:"unblocking line ",i:lineid);
			//Line_SetBlocking(lineid,0,32);	//all
			Line_SetBlocking(lineid,0,64);		//mid
		}
	}
}

/* scripted 3d door. Move control sector 'tag' by 'distance' to simulate doors with 3D sectors */
script 4(int tag, int distance, int stayopen){
	/* 
	Prevent logical door height errors:
	 - if 'stayopen', activators MUST be s1/w1 etc.
	 - if repeatable door, need to check initial height and prevent retrigger until returned, otherwise
	   the door can be lowered into the floor...
	*/
	
	int _controlSectorStartingHeight = (GetSectorFloorZ(tag,0,0)/65536);
	//print(s:"control sector floor height: ",i:_controlSectorStartingHeight);

	//use the same TID for soundspot
	floorandceiling_raisebyvalue(tag,12,distance);
	ThingSound(40,"doors/dr1_open",127);
	//TagWait (tag);
	
	delay(108);	//allow time to finish
	//print(i:stayopen);
	//print(s:"opened door height: ",i:((GetSectorFloorZ(tag,0,0)/65536)));
	/* only trigger if the initial height == starting height. This prevents logical errors when triggering the door again if it has not returned to the correct height  */
	if(stayopen == 0 && (GetSectorFloorZ(tag,0,0)/65536) == _controlSectorStartingHeight+distance){
		floorandceiling_lowerbyvalue(tag,12,distance);
		ThingSound(40,"doors/dr1_clos",127);
	}
}

script 5 (int msgindex){
	int msgs[2] = {
	"Blocked... Must be opened elsewhere...",
	"This must open those bars..."
	};
	print(s:msgs[msgindex]);
}

/* lower bars to level 3: */
script 6(int floorToLower,int dist,int _return){
	Floor_LowerByValue(floorToLower,12,dist);
	if(_return > 0){
		Delay(210);
		Floor_RaiseByValue(floorToLower,12,dist);
	}
}


